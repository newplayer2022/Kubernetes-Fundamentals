A unit of software /deployment
code, runtime,system,system library

move faster by deploying smaller units
usefewer resources
fit moret into the same host
faster automation
portability
isloation(fail, not taking whole system down)
made of layers

docker image inspect  #get image info
docker ps -a # running and stopped containers
docker ps # running containers
docker pull/run/start/stop/kill
docker rm #removes stopped containers 
docker rm $(docker ps -a -q) #removes all stopped containers
docker rmi #delete images 
docker system prune -a #removes all images not in use by any containers






https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/#install-kubectl-binary-with-curl-on-windows
k8s is the container orchestration tool
from google
a collection of compents centered around deploying, maintain and scaling workloads
vendor-neutral---runs on al cloud providers
backed by a huge community

can do
service discovery and load balancing
storage orchestration(local or clooud based)
automated rollouts and rollbacks
self-healing
secret and configuration management
same API  across on-permison and all cloud provider


cant do:
not deploy source code
not build application 
not provide application -level servise

architecture
pod-node-cluster

run locally
docker desktop is the currently only way to run both linux and windows containers

docker desktop
microk8s
minikube

over docker desktop #1node
kind

run kubectl cluster-info to check the status if k8s is running correct, showing on VS code
#PS C:\apps> kubectl cluster-info
Kubernetes control plane is running at https://kubernetes.docker.internal:6443
CoreDNS is running at https://kubernetes.docker.internal:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy


kubectl config current-context #get the current context
kubectl config get-contexts # list all context
kubectl config use-context [contextName] #set the current context
kubectl config delete-context[contextName] #delete a contedxt from the config file 

 

2ways declarative and imperative
imperative using kubectl commands, great for learning, testing, and troublshooting
declarative way using YAML manifests ,reproducible, repeatable, can be saved in source control 

PS C:\apps> kubectl create deployment mynginx1 --image=nginx
deployment.apps/mynginx1 created

PS C:\apps> kubectl get deploy
NAME       READY   UP-TO-DATE   AVAILABLE   AGE
mynginx1   1/1     1            1           48s

PS C:\apps> kubectl create -f deploy-example.yaml
deployment.apps/nginx-deployment created
PS C:\apps> kubectl get deploy
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
mynginx1           1/1     1            1           4m29s
nginx-deployment   3/3     3            3           20s

kubectl delete deployment
kubectl delete deploy

#group ex.dev/prod/test
kubectl get namespaces
kubectl get ns              #get current configured namespaces
kubectl get pods            #get a list of all the installed pods
kubectl config set-context --curent -- namespace=[namespaceName]

kube-control-manager
runs controllers/node controller/replication controller/endpoints controller/service account and token controllers
cloud-control-manager
node/route/service
kube-scheduler
watches newly created pods and selects a node for it to run
kubelet
manage the pods lifecycle, make sure containers described in the pod specs are running and healthy
kube poxy network proxy/manage network rules on nodes

kubectl describe node
kubectl get nodes

pods 
atomic unit of the smallest unit of work of k8s
represents a unit of deployment
pods can run one or multiple containers
containers within a pod share ip address space, mountedf volumes,use local host(inside of the pod)
y7ou dont update a pod, you replace it within an updated version

kubectl creat -f [pod-definition.yml]
kubectl run [podname] --image=busybox --/bin/sh/ -c "sleep 3600" 
kubectl get pods
describe pod [podname]
exec -it [podname] --sh
delete -f [podname]
kubectl get pods -o wide

kubectl exec -it [podname] -c[containername] -- sh   #jump into the one of the container in the pod
kubectl logs [podname] -c [containername]   #check logs


kubectl apply -f [definition.yaml]
kubectl get rs  #list replicasets
kubectl describe rs [rsname]
kubectl delete rs 
